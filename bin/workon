#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

VERSION="0.1.0"

SCRIPT_REALPATH="$(realpath "$0")"
SCRIPT_DIR="$(dirname "$SCRIPT_REALPATH")"
WORKON_DIR="$(dirname "$SCRIPT_DIR")"

# Source the library functions
# shellcheck source=lib/workon.sh disable=SC1091
source "$WORKON_DIR/lib/workon.sh"

# Print usage information
usage() {
    cat <<EOF
workon â€” one-shot project workspace bootstrapper

Usage: workon [COMMAND] [OPTIONS] [PROJECT_PATH]

Commands:
  start             Start workspace (default command)
  stop              Stop workspace and clean up session

Options:
  -v, --version     Show version information
  -h, --help        Show this help

Arguments:
  PROJECT_PATH      Directory containing workon.yaml (default: current directory)

Examples:
  workon                    # Start workspace from current directory
  workon start ~/my-project # Start workspace from specific directory
  workon stop               # Stop current workspace session
  workon stop ~/my-project  # Stop workspace session in specific directory
EOF
}

# Main workon start function
workon_start() {
    local project_path="${1:-$PWD}"
    local manifest
    
    # Check dependencies
    check_dependencies

    # Find manifest file
    if ! manifest=$(find_manifest "$project_path"); then
        die "No workon.yaml found in $project_path or parent directories"
    fi
    
    printf 'Found manifest: %s\n' "$manifest" >&2
    
    # Parse and validate manifest
    local manifest_json
    manifest_json=$(parse_manifest "$manifest")
    
    # Extract resources
    local resources
    resources=$(extract_resources "$manifest_json")

    # Change to manifest directory for relative paths
    local manifest_dir
    manifest_dir=$(dirname "$manifest")
    cd "$manifest_dir" || die "Cannot change to manifest directory: $manifest_dir"
    
    # Initialize session tracking
    local session_file
    session_file=$(cache_file "$manifest_dir")
    
    # Check if session already exists
    if [[ -f $session_file ]]; then
        printf 'Warning: Session file already exists at %s\n' "$session_file" >&2
        printf 'Run "workon stop" first to clean up previous session\n' >&2
    fi
    
    # Spawn each resource with session tracking
    local count=0
    printf 'Starting resources:\n' >&2
    
    while read -r entry; do
        if [[ -z $entry ]]; then
            continue
        fi
        
        local name raw_cmd rendered_cmd
        name=$(printf '%s' "$entry" | base64 -d | jq -r '.key' 2>/dev/null) || continue
        raw_cmd=$(printf '%s' "$entry" | base64 -d | jq -r '.value' 2>/dev/null) || continue

        # Render template variables
        rendered_cmd=$(render_template "$raw_cmd")
        
        # Launch resource and record in session
        if launch_resource_with_session "$session_file" "$name" "$rendered_cmd"; then
            count=$((count + 1))
        fi
        
    done <<<"$resources"
    
    # Wait for all background processes
    wait
    
    printf 'Started %d resources (session: %s)\n' "$count" "$(basename "$session_file")" >&2
}

# Stop workspace and clean up session
workon_stop() {
    local project_path="${1:-$PWD}"
    local manifest_dir
    
    # Find manifest directory to determine session file
    local manifest
    if ! manifest=$(find_manifest "$project_path"); then
        # Try using the current directory if no manifest found
        manifest_dir=$(realpath "$project_path")
    else
        manifest_dir=$(dirname "$manifest")
    fi
    
    local session_file
    session_file=$(cache_file "$manifest_dir")
    
    # Check if session file exists
    if [[ ! -f $session_file ]]; then
        printf 'No active session found for %s\n' "$manifest_dir" >&2
        return 0
    fi
    
    printf 'Stopping session: %s\n' "$(basename "$session_file")" >&2
    
    # Stop session with file locking
    with_lock "$session_file" stop_session_impl "$session_file"
    
    printf 'Session stopped and cleaned up\n' >&2
}

# Parse command line arguments
command=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        -v|--version)
            printf 'workon %s\n' "$VERSION"
            exit 0
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        start|stop)
            command="$1"
            shift
            ;;
        -*)
            die "Unknown option: $1"
            ;;
        *)
            # This is the project path
            break
            ;;
    esac
done

# Default to start command if none specified
if [[ -z $command ]]; then
    command="start"
fi

# Execute the appropriate command
case "$command" in
    start)
        workon_start "$@"
        ;;
    stop)
        workon_stop "$@"
        ;;
    *)
        die "Unknown command: $command"
        ;;
esac
