#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

VERSION="0.1.0"

SCRIPT_REALPATH="$(realpath "$0")"
SCRIPT_DIR="$(dirname "$SCRIPT_REALPATH")"
WORKON_DIR="$(dirname "$SCRIPT_DIR")"

# Source the library functions
# shellcheck source=lib/workon.sh disable=SC1091
source "$WORKON_DIR/lib/workon.sh"

# Print usage information
usage() {
    cat <<EOF
workon â€” one-shot project workspace bootstrapper

Usage: workon [COMMAND] [OPTIONS] [PROJECT_PATH]

Commands:
  start             Start workspace (default command)
  stop              Stop workspace and clean up session
  info              Show system information and debug details
  validate          Validate workon.yaml manifest file
  resolve           Show resolved command for a resource

Options:
  -v, --version     Show version information
  -h, --help        Show this help
  --debug           Enable debug mode (shows all internal operations)
  --verbose         Enable verbose output (shows progress details)
  --dry-run         Validate and show what would be executed without running

Arguments:
  PROJECT_PATH      Directory containing workon.yaml (default: current directory)

Examples:
  workon                    # Start workspace from current directory
  workon start ~/my-project # Start workspace from specific directory
  workon --debug start      # Start with full debug output
  workon --verbose start    # Start with progress details
  workon --dry-run start    # Show what would be executed
  workon stop               # Stop current workspace session
  workon info               # Show system information and dependencies
  workon validate           # Validate current directory's workon.yaml
  workon resolve ide        # Show resolved command for 'ide' resource

Environment Variables:
  WORKON_DEBUG=1           Enable debug mode globally
  WORKON_VERBOSE=1         Enable verbose mode globally
  WORKON_DRY_RUN=1         Enable dry-run mode globally
EOF
}

# Main workon start function
workon_start() {
    local project_path="${1:-$PWD}"
    local manifest
    
    # Show debug information
    debug_show_environment
    debug_show_system_info
    
    # Run pre-flight checks if debug or verbose mode
    if [[ "${WORKON_DEBUG:-0}" == "1" ]] || [[ "${WORKON_VERBOSE:-0}" == "1" ]]; then
        verbose_log "Running pre-flight system checks..."
        if ! debug_preflight_checks; then
            if [[ "${WORKON_DEBUG:-0}" == "1" ]]; then
                die "Pre-flight checks failed. Use --debug for more details."
            else
                warn_log "Some pre-flight checks failed, but continuing anyway"
            fi
        fi
    fi
    
    # Check dependencies
    verbose_log "Checking basic dependencies..."
    check_dependencies

    # Find manifest file
    verbose_log "Looking for workon.yaml in $project_path and parent directories..."
    if ! manifest=$(find_manifest "$project_path"); then
        die "No workon.yaml found in $project_path or parent directories"
    fi
    
    success_log "Found manifest: $manifest"
    debug_var "manifest"
    
    # Parse and validate manifest
    verbose_log "Parsing and validating manifest..."
    local manifest_json
    manifest_json=$(parse_manifest "$manifest")
    debug_file "$manifest" "workon.yaml manifest"
    
    # Extract resources
    verbose_log "Extracting resources from manifest..."
    local resources
    resources=$(extract_resources "$manifest_json")
    debug_var "resources"
    
    # Extract layout configuration (optional)
    verbose_log "Checking for layout configuration..."
    local layout=""
    layout=$(manifest_extract_layout "$manifest_json" || true)
    debug_var "layout"

    # Change to manifest directory for relative paths
    local manifest_dir
    manifest_dir=$(dirname "$manifest")
    verbose_log "Changing to manifest directory: $manifest_dir"
    cd "$manifest_dir" || die "Cannot change to manifest directory: $manifest_dir"
    
    # Initialize session tracking
    verbose_log "Setting up session tracking..."
    mkdir -p "$(cache_dir)" || die "Cannot create cache directory"
    local session_file
    session_file=$(cache_file "$manifest_dir")
    debug_var "session_file"

    success_log "Starting workspace in: $manifest_dir"
    verbose_log "Session file: $session_file"
    
    # Check if session already exists
    if [[ -f $session_file ]]; then
        printf 'Warning: Session file already exists at %s\n' "$session_file" >&2
        printf 'Run "workon stop" first to clean up previous session\n' >&2
    fi
    
    # Launch all resources using single Lua script
    if launch_all_resources_with_session "$session_file" "$resources" "$layout"; then
        # Report final status
        if [[ -f "$session_file" ]]; then
            local final_count
            final_count=$(jq 'length' "$session_file" 2>/dev/null || echo 0)
            printf 'Successfully started %d resources (session: %s)\n' "$final_count" "$(basename "$session_file")" >&2
        else
            printf 'Resources spawned but session file not found\n' >&2
        fi
    else
        printf 'Error: Failed to spawn resources\n' >&2
        return 1
    fi
}

# Stop workspace and clean up session
workon_stop() {
    local project_path="${1:-$PWD}"
    local manifest_dir
    
    # Find manifest directory to determine session file
    local manifest
    if ! manifest=$(find_manifest "$project_path"); then
        # Try using the current directory if no manifest found
        manifest_dir=$(realpath "$project_path")
    else
        manifest_dir=$(dirname "$manifest")
    fi
    
    local session_file
    session_file=$(cache_file "$manifest_dir")
    
    # Check if session file exists
    if [[ ! -f $session_file ]]; then
        printf 'No active session found for %s\n' "$manifest_dir" >&2
        return 0
    fi
    
    verbose_log 'Stopping session: %s\n' "$(basename "$session_file")" >&2
    
    # Stop session with file locking
    with_lock "$session_file" stop_session_impl "$session_file"
    
    printf 'Session stopped and cleaned up\n' >&2
}

# Global debug flags
export WORKON_DEBUG="${WORKON_DEBUG:-0}"
export WORKON_VERBOSE="${WORKON_VERBOSE:-0}"
export WORKON_DRY_RUN="${WORKON_DRY_RUN:-0}"

# Parse command line arguments
command=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        -v|--version)
            printf 'workon %s\n' "$VERSION"
            exit 0
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        --debug)
            export WORKON_DEBUG=1
            export WORKON_VERBOSE=1  # Debug implies verbose
            shift
            ;;
        --verbose)
            export WORKON_VERBOSE=1
            shift
            ;;
        --dry-run)
            export WORKON_DRY_RUN=1
            export WORKON_VERBOSE=1  # Dry-run implies verbose
            shift
            ;;
        start|stop|info|validate|resolve)
            command="$1"
            shift
            ;;
        -*)
            die "Unknown option: $1"
            ;;
        *)
            # This is the project path
            break
            ;;
    esac
done

# Default to start command if none specified
if [[ -z $command ]]; then
    command="start"
fi

# Execute the appropriate command
case "$command" in
    start)
        workon_start "$@"
        ;;
    stop)
        workon_stop "$@"
        ;;
    info)
        workon_info "$@"
        ;;
    validate)
        workon_validate "$@"
        ;;
    resolve)
        workon_resolve "$@"
        ;;
    *)
        die "Unknown command: $command"
        ;;
esac
