#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

VERSION="0.1.0-alpha"

SCRIPT_REALPATH="$(realpath "$0")"
SCRIPT_DIR="$(dirname "$SCRIPT_REALPATH")"
WORKON_DIR="$(dirname "$SCRIPT_DIR")"

# Source the library functions
# shellcheck source=lib/workon.sh disable=SC1091
source "$WORKON_DIR/lib/workon.sh"

# Print usage information
usage() {
    cat <<EOF
workon â€” one-shot project workspace bootstrapper

Usage: workon [COMMAND] [OPTIONS] [PROJECT_PATH]

Commands:
  start             Start workspace (default command)
  stop              Stop workspace (coming in Phase 2)

Options:
  -v, --version     Show version information
  -h, --help        Show this help

Arguments:
  PROJECT_PATH      Directory containing workon.yaml (default: current directory)

Examples:
  workon                    # Start workspace from current directory
  workon start ~/my-project # Start workspace from specific directory
EOF
}

# Main workon start function
workon_start() {
    local project_path="${1:-$PWD}"
    local manifest
    
    # Check dependencies
    check_dependencies
    
    # Find manifest file
    if ! manifest=$(find_manifest "$project_path"); then
        die "No workon.yaml found in $project_path or parent directories"
    fi
    
    printf 'Found manifest: %s\n' "$manifest" >&2
    
    # Parse and validate manifest
    local manifest_json
    manifest_json=$(parse_manifest "$manifest")
    
    # Extract resources
    local resources
    resources=$(extract_resources "$manifest_json")
    
    # Change to manifest directory for relative paths
    local manifest_dir
    manifest_dir=$(dirname "$manifest")
    cd "$manifest_dir" || die "Cannot change to manifest directory: $manifest_dir"
    
    # Spawn each resource
    local count=0
    printf 'Starting resources:\n' >&2
    
    while read -r entry; do
        if [[ -z $entry ]]; then
            continue
        fi
        
        local name raw_cmd rendered_cmd
        name=$(printf '%s' "$entry" | base64 -d | jq -r '.key' 2>/dev/null) || continue
        raw_cmd=$(printf '%s' "$entry" | base64 -d | jq -r '.value' 2>/dev/null) || continue
        
        # Render template variables
        rendered_cmd=$(render_template "$raw_cmd")
        
        # Launch resource
        if launch_resource "$name" "$rendered_cmd"; then
            count=$((count + 1))
        fi
        
    done <<<"$resources"
    
    # Wait for all background processes
    wait
    
    printf 'Started %d resources\n' "$count" >&2
}

# Placeholder for stop functionality (Phase 2)
workon_stop() {
    die "Stop functionality not yet implemented (coming in Phase 2)"
}

# Parse command line arguments
command=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        -v|--version)
            printf 'workon %s\n' "$VERSION"
            exit 0
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        start|stop)
            command="$1"
            shift
            ;;
        -*)
            die "Unknown option: $1"
            ;;
        *)
            # This is the project path
            break
            ;;
    esac
done

# Default to start command if none specified
if [[ -z $command ]]; then
    command="start"
fi

# Execute the appropriate command
case "$command" in
    start)
        workon_start "$@"
        ;;
    stop)
        workon_stop "$@"
        ;;
    *)
        die "Unknown command: $command"
        ;;
esac